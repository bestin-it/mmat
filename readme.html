<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MMAT - Model-based Manual Acceptance Testing framework</title>
  <style>
    /* ----------------------------------------
       Reset and base styles for the page
       ---------------------------------------- */
    body {
      margin: 0;
      padding: 0;
      font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,
        "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      line-height: 1.6;
      background-color: #f4f7f6;
      color: #333;
    }

    /* ----------------------------------------
       Centered wrapper at 80% of viewport width
       ---------------------------------------- */
    .wrapper {
      width: 70vw;           /* 80% of the viewport width */
      margin: 0 auto;        /* center horizontally */
      padding: 20px 0;       /* top & bottom padding */
      box-sizing: border-box;
    }

    /* ----------------------------------------
       Flex container with min-height 95vh
       ---------------------------------------- */
    .container {
      display: flex;
      min-height: 95vh;      /* at least 95% of the viewport height */
      /* No fixed height beyond min-height; grows with content */
    }

    /* ----------------------------------------
       Sidebar (left menu)
       ----------------------------------------
       • Fixed width: 300px
       • “Floating” next to content via position: sticky
       • Stretches to at least 95vh, but grows with content
       ---------------------------------------- */
    .sidebar {
      width: 300px;                  /* fixed width for sidebar */
      background-color: #e9ecef;
      padding: 20px 0 20px 20px;
      box-shadow: 2px 0 4px rgba(0, 0, 0, 0.05);
      overflow-y: auto;
      flex-shrink: 0;                /* do not shrink below 300px */
      position: sticky;              /* “float” as you scroll */
      top: 20px;                     /* stick 20px from top of viewport */
      align-self: flex-start;        /* ensures sticky works inside flex */
      box-sizing: border-box;
      border-right: 1px solid #ccc;
    }

    .sidebar h3 {
      color: #0056b3;
      margin-top: 0;
      padding-bottom: 5px;
      border-bottom: 1px solid #ccc;
      margin-bottom: 15px;
      font-size: 1.2em;
    }

    .sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sidebar li {
      margin-bottom: 5px;
    }

    .sidebar a {
      display: block;
      color: #333;
      text-decoration: none;
      padding: 5px 10px;
      border-radius: 3px;
      transition: background-color 0.2s ease;
      font-size: 1em;
    }

    .sidebar a:hover {
      background-color: #dcdcdc;
      text-decoration: none;
    }

    .sidebar a.active {
      background-color: #007bff;
      color: white;
    }

    .sidebar ul ul {
      padding-left: 20px;
      margin-top: 5px;
    }

    /* ----------------------------------------
       Main content area
       ----------------------------------------
       • Pushed right by sidebar’s 300px
       • Width = calc(100% - 300px)
       • Grows beyond 95vh if content is longer
       ---------------------------------------- */
    .main-content {
      flex-grow: 1;
      margin-left: 0px;              /* same as .sidebar width */
      padding: 0 20px 20px 20px;
      overflow-y: auto;
      width: 95%;
      box-sizing: border-box;
    }

    /* ----------------------------------------
       Inner white container for actual content
       ---------------------------------------- */
    .container-inner {
      max-width: 100%;
      margin: 0 auto;
      background-color: #fff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      box-sizing: border-box;
    }

    /* Each section is hidden by default; shown when “active” */
    .content-section {
      display: none;
    }

    .content-section.active {
      display: block;
    }

    /* ----------------------------------------
       Heading styles
       ---------------------------------------- */
    h1, h2, h3 {
      color: #0056b3;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    h1 {
      border-bottom: 2px solid #0056b3;
      padding-bottom: 10px;
      margin-bottom: 20px;
      font-size: 2em;
    }

    h2 {
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
      margin-bottom: 15px;
      font-size: 1.5em;
    }

    h3 {
      font-size: 1.2em;
    }

    /* ----------------------------------------
       Paragraph, list, and code styling
       ---------------------------------------- */
    p {
      margin-bottom: 15px;
    }

    ul, ol {
      margin-bottom: 15px;
      padding-left: 20px;
    }

    li {
      margin-bottom: 8px;
    }

    pre {
      background-color: #e9ecef;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      margin-bottom: 15px;
    }

    code {
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
    }

    pre code {
      display: block;
      padding: 0;
      background-color: transparent;
    }

    a {
      color: #007bff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <!-- Centered wrapper -->
  <div class="wrapper">
    <div class="container">
      <!-- Sidebar menu -->
      <div class="sidebar">
        <h3>Table of Contents</h3>
        <ul>
          <li><a href="#section-overview">1. Overview</a></li>
          <li><a href="#section-installation">2. Installation</a></li>
          <li>
            <a href="#section-project-setup-and-structure">3. Project Setup and Structure</a>
            <ul>
              <li><a href="#section-functional-description">3.1. Functional Description</a></li>
              <li><a href="#section-functional-test-plan">3.2. Functional Test Plan</a></li>
              <li><a href="#section-e2e-test-in-playwright">3.3. E2E Test in Playwright</a></li>
              <li><a href="#section-config">3.4. Configuration (config.yaml) and Models</a></li>
            </ul>
          </li>
          <li><a href="#section-understanding-graphs-in-mmat">4. Understanding Graphs in MMAT</a></li>
          <li>
            <a href="#section-usage-planned">5. Usage (Planned)</a>
            <ul>
              <li><a href="#section-mmat-run">5.1. mmat run</a></li>
              <li><a href="#section-mmat-build">5.2. mmat build</a></li>
              <li><a href="#section-mmat-export">5.3. mmat export</a></li>
              <li><a href="#section-mmat-import-e2e">5.4. mmat import-e2e</a></li>
            </ul>
          </li>
          <li><a href="#section-contributing-planned">6. Contributing (Planned)</a></li>
          <li><a href="#section-license">7. License</a></li>
          <li><a href="#section-acknowledgments">8. Acknowledgments</a></li>
          <li><a href="#section-features-planned">9. Features (Planned)</a></li>
        </ul>
      </div>

      <!-- Main content area -->
      <div class="main-content">
        <div class="container-inner">
          <!-- 1. Overview -->
          <div id="section-overview" class="content-section">
            <h1 id="mmat-model-based-manual-acceptance-testing-framework">
              1. MMAT – Model-based Manual Acceptance Testing framework
            </h1>
            <p>
              MMAT is a Python framework designed to facilitate model-based manual acceptance testing. It leverages various components like
              reasoning models, vision models, and environments (like browsers) to automate the process of generating, executing, and reporting
              on manual acceptance tests based on functional descriptions or other data sources.
            </p>
            <p>
              The core idea is to start with a simple description or prompt of the desired functionality. MMAT can then interact with a given URL
              or web page(s) to understand the user interface and behavior. Based on this analysis, the framework aims to generate a structured
              test plan, typically in JSON or YAML format. This plan describes the test with a clear list of steps needed to repeat the manual
              acceptance test.
            </p>
            <p>
              Furthermore, MMAT is designed to allow users to generate executable code, such as Playwright Python scripts, directly from this
              structured test plan. The framework should also provide the capability to run this generated code, enabling automated execution of
              the manual acceptance tests defined through the model-based approach.
            </p>
          </div>

          <!-- 2. Installation -->
          <div id="section-installation" class="content-section">
            <h2 id="installation">2. Installation</h2>
            <p>MMAT is a Python package.</p>
            <p><strong>Prerequisites:</strong></p>
            <ul>
              <li>Python 3.8+</li>
            </ul>
            <h3>Installing via Pip from GitHub</h3>
            <p>You can install MMAT directly from the GitHub repository using pip:</p>
            <pre><code class="language-bash">pip install git+https://github.com/yourusername/mmat.git</code></pre>
            <p>Replace <code>yourusername</code> with the actual GitHub username or organization.</p>

            <h3>Setting up the 'mmat' Alias on Windows</h3>
            <p>To set up the <code>mmat</code> alias on Windows, run the provided <code>setup.py</code> script from the project root (<code>c:/Projects/Matt</code>):</p>
            <pre><code class="language-bash">python setup.py install</code></pre>
            <p>This script creates the <code>mmat</code> alias, allowing you to run MMAT commands from any directory in your Windows terminal (Command Prompt or PowerShell).</p>
            <p>Example usage:</p>
            <pre><code class="language-bash">mmat --help</code></pre>
          </div>

          <!-- 3. Project Setup and Structure -->
          <div id="section-project-setup-and-structure" class="content-section">
            <h2 id="project-setup-and-structure">3. Project Setup and Structure</h2>
            <p>MMAT provides an <code>init</code> command to help you quickly set up a basic project structure. This command creates a directory with a suggested layout for your test assets and configuration.</p>
            <p>To initialize a new MMAT project, navigate to the directory where you want to create the project and run:</p>
            <pre><code class="language-bash">mmat init [project_name]</code></pre>
            <ul>
              <li><code>[project_name]</code> (Optional): The name of the directory to create for your project. If not provided, it defaults to <code>my_mmat_project</code>.</li>
            </ul>
            <p>This will create a directory structure similar to:</p>
            <pre><code>[project_name]/
├── functional_descriptions/
│   └── # Your functional descriptions go here (e.g., login.md)
├── tests/
│   ├── functional/
│   │   └── # Your functional test plans go here (e.g., login_test_plan.yaml)
│   └── e2e/
│       └── # Your exported e2e tests go here (e.g., login_test.py)
├── config/
│   └── config.yaml # Your MMAT configuration file
└── # Other project files (e.g., requirements.txt, README.md)</code></pre>
            <p>After initialization, you’ll integrate the <code>mmat</code> library into your project’s dependencies (e.g., adding <code>mmat</code> to <code>requirements.txt</code>).</p>
            <p>The typical structure when using <code>mmat</code> might look like:</p>
            <pre><code>your_project/
├── functional_descriptions/
│   └── login.md
├── tests/
│   ├── functional/
│   │   └── login_test_plan.yaml
│   └── e2e/
│       └── login_test.py
├── config/
│   └── config.yaml
├── src/ # Your application source code
│   └── …
├── .gitignore
├── requirements.txt # Project dependencies
└── README.md # Project’s README</code></pre>
            <p>In this structure:</p>
            <ul>
              <li><code>functional_descriptions/</code>: Store your functional requirements, typically in Markdown.</li>
              <li><code>tests/functional/</code>: Store your functional test plans (YAML or JSON), which can be generated from functional descriptions or written manually.</li>
              <li><code>tests/e2e/</code>: Store exported end-to-end test scripts (e.g., Playwright Python).</li>
              <li><code>config/</code>: Keep <code>config.yaml</code> (MMAT’s global configuration for models, environments, etc.).</li>
              <li><code>requirements.txt</code>: List <code>mmat</code> and any other dependencies.</li>
            </ul>

            <!-- 3.1 Functional Description -->
            <div id="section-functional-description" class="content-section">
              <h3 id="functional-description">3.1. Functional Description</h3>
              <p>Functional descriptions are the starting point for generating test plans using MMAT's <code>build</code> command. These files describe the desired behavior of your application or specific features. They are typically written in a human-readable format like Markdown.</p>
              <p>Example: <code>functional_descriptions/login.md</code></p>
              <pre><code class="language-markdown"># User Login Feature

## Description
This feature allows users to log in to the application using their username and password.

## Requirements
- Users must be able to enter their username and password.
- Upon successful login with valid credentials, the user should be redirected to the dashboard.
- If the user provides invalid credentials, an error message should be displayed.
- There should be a "Forgot Password" link.

## Scenarios
- **Successful Login:**
  - Given the user is on the login page
  - When they enter valid username and password
  - And click the login button
  - Then they should be redirected to the dashboard.

- **Failed Login (Invalid Password):**
  - Given the user is on the login page
  - When they enter a valid username and an invalid password
  - And click the login button
  - Then an error message should be displayed.
</code></pre>
            </div>

            <!-- 3.2 Functional Test Plan -->
            <div id="section-functional-test-plan" class="content-section">
              <h3 id="functional-test-plan">3.2. Functional Test Plan</h3>
              <p>Functional tests in MMAT are defined in structured test plans, typically in YAML or JSON format. These plans outline the sequence of steps to perform a specific test case. They can be generated automatically from functional descriptions using the <code>mmat build</code> command or written manually.</p>
              <p>Example: <code>tests/functional/login_test_plan.yaml</code> (Generated from the functional description above)</p>
              <pre><code class="language-yaml">test_plan:
  name: User Login Tests
  description: Tests for the user login feature
  test_suites:
    - name: Standard Login
      description: Test standard user login scenarios
      test_cases:
        - name: Successful Login with Valid Credentials
          description: Verify a user can log in successfully
          steps:
            - action: navigate
              target: /login
              description: Go to the login page
            - action: fill
              selector: '#username'
              value: testuser
              description: Enter valid username
            - action: fill
              selector: '#password'
              value: password123
              description: Enter valid password
            - action: click
              selector: '#login-button'
              description: Click the login button
            - action: assert_url
              expected: /dashboard
              description: Verify redirection to dashboard
        - name: Failed Login with Invalid Password
          description: Verify login fails with incorrect password
          steps:
            - action: navigate
              target: /login
              description: Go to the login page
            - action: fill
              selector: '#username'
              value: testuser
              description: Enter valid username
            - action: fill
              selector: '#password'
              value: wrongpassword
              description: Enter invalid password
            - action: click
              selector: '#login-button'
              description: Click the login button
            - action: assert_element_visible
              selector: '.error-message'
              description: Verify error message is displayed</code></pre>
            </div>

            <!-- 3.3 E2E Test in Playwright -->
            <div id="section-e2e-test-in-playwright" class="content-section">
              <h3 id="e2e-test-in-playwright">3.3. E2E Test in Playwright</h3>
              <p>MMAT can export functional test plans into executable end-to-end test scripts for frameworks like Playwright. These exported scripts can be run independently of MMAT or used as a starting point for further test development. These files are typically stored in the <code>tests/e2e/</code> directory.</p>
              <p>Example: <code>tests/e2e/login_test.py</code> (Exported from the functional test plan above)</p>
              <pre><code class="language-python">import pytest
from playwright.sync_api import Page, sync_playwright

# Test Suite: Standard Login
# Description: Test standard user login scenarios

# Test Case: Successful Login with Valid Credentials
# Description: Verify a user can log in successfully
def test_successful_login(page: Page):
    page.goto("/login")
    page.fill('#username', 'testuser')
    page.fill('#password', 'password123')
    page.click('#login-button')
    # Verify redirection to dashboard
    assert page.url.endswith('/dashboard')

# Test Case: Failed Login with Invalid Password
# Description: Verify login fails with incorrect password
def test_failed_login_invalid_password(page: Page):
    page.goto("/login")
    page.fill('#username', 'testuser')
    page.fill('#password', 'wrongpassword')
    page.click('#login-button')
    # Verify error message is displayed
    assert page.is_visible('.error-message')</code></pre>
            </div>

            <!-- 3.4 Configuration (config.yaml) and Models -->
            <div id="section-config" class="content-section">
              <h3 id="config">3.4. Configuration (config.yaml) and Models</h3>
              <p>The <code>config.yaml</code> file contains the global configuration for your MMAT project. This includes settings for environments (like browsers), models (reasoning and vision), and reporting. This file is typically located at the root of your project's configuration directory.</p>
              <p>Example: <code>config/config.yaml</code></p>
              <pre><code class="language-yaml">environments:
  browser:
    type: puppeteer
    config:
      baseUrl: http://localhost:3000 # Replace with your application’s base URL
      headless: true # Set to false to see the browser
      defaultTimeout: 10000 # Milliseconds

models:
  reasoning:
    provider: local_api # Example: using a local API endpoint
    type: llm
    config:
      endpoint: http://localhost:8000/v1
      model_name: my-local-llm

vision:
    provider: local_ollama # Example: using Ollama
    type: vision
    config:
      model_name: llava:7b
      endpoint: http://localhost:11434/api/generate

reporting:
  - type: json
    config:
      outputDir: ./reports</code></pre>
              <p>
                MMAT utilizes Language Models (LLMs) and Vision Models (VMs) for various tasks, including test plan generation and analysis. The configuration for these models is managed within the <code>config.yaml</code> file, typically located in your project's <code>config/</code> directory.
              </p>
              <p>
                The <code>models</code> section in <code>config.yaml</code> allows you to define different model providers and their specific configurations. MMAT supports various providers, and you can configure multiple models for different purposes (e.g., a reasoning model for generating test steps and a vision model for analyzing screenshots).
              </p>
              <p>Example <code>models</code> section in <code>config/config.yaml</code>:</p>
              <pre><code class="language-yaml">models:
  reasoning:
    provider: local_api # Example: using a local API endpoint
    type: llm
    config:
      endpoint: http://localhost:8000/v1
      model_name: my-local-llm

  vision:
    provider: local_ollama # Example: using Ollama
    type: vision
    config:
      model_name: llava:7b
      endpoint: http://localhost:11434/api/generate

  # You can add configurations for other models or providers here
  another_model:
    provider: openai
    type: llm
    config:
      model_name: gpt-4o
      api_key: ${OPENAI_API_KEY} # Using environment variable
</code></pre>
              <p>
                Key parameters within a model configuration typically include:
              </p>
              <ul>
                <li><code>provider</code>: Specifies the service or tool providing the model (e.g., <code>local_api</code>, <code>local_ollama</code>, <code>openai</code>, <code>lm_studio</code>).</li>
                <li><code>type</code>: Indicates the type of model (e.g., <code>llm</code> for Language Models, <code>vision</code> for Vision Models).</li>
                <li><code>config</code>: A dictionary containing provider-specific settings, such as API endpoints, model names, API keys, etc.</li>
              </ul>
              <p>
                Ensure that the <code>endpoint</code> and <code>model_name</code> in your configuration accurately reflect the models you have available and how they are being served (e.g., via LM Studio, Ollama, or a cloud service). You can use environment variables (e.g., <code>${OPENAI_API_KEY}</code>) for sensitive information like API keys.
              </p>

              <h3 id="setting-up-local-models-with-lm-studio">Setting up Local Models (LM Studio)</h3>
              <p>
                MMAT can utilize local Language Models (LLMs) and Vision Models (VMs) for tasks like test plan generation and analysis. LM Studio
                is a popular desktop application that allows you to discover, download, and run local LLMs.
              </p>
              <p>Here’s how to set up LM Studio and configure MMAT to use models served by it:</p>
              <ol>
                <li>
                  <p><strong>Download and Install LM Studio:</strong></p>
                  <ul>
                    <li>Go to the <a href="https://lmstudio.ai/">LM Studio website</a> and download the appropriate version for your OS (Windows, macOS, Linux).</li>
                    <li>Install LM Studio following the on-screen instructions.</li>
                  </ul>
                </li>
                <li>
                  <p><strong>Download Models in LM Studio:</strong></p>
                  <ul>
                    <li>Open LM Studio.</li>
                    <li>Use the search bar to find models. For MMAT, you’ll likely need a reasoning model (general-purpose LLM) and potentially a multimodal/vision model (e.g., LLaVA) if you plan to use vision-based features.</li>
                    <li>Click “Download” next to the models you want. Choose a suitable size/quantization (e.g., Q4_K_M for a balance of speed vs. quality).</li>
                  </ul>
                </li>
                <li>
                  <p><strong>Serve Models in LM Studio:</strong></p>
                  <ul>
                    <li>Go to the “Local Inference Server” tab (usually the third icon from the top). Select the model to serve from the dropdown.</li>
                    <li>Click “Start Server.” LM Studio will display an API endpoint (e.g., <code>http://localhost:1234</code>).</li>
                  </ul>
                </li>
                <li>
                  <p><strong>Configure MMAT’s <code>config.yaml</code>:</strong></p>
                  <ul>
                    <li>Open your project’s <code>config/config.yaml</code>.</li>
                    <li>Modify the <code>models</code> section to point to LM Studio’s endpoint. Refer to <a href="#section-config">Section 3.4</a> for a detailed example of the <code>config.yaml</code> structure.</li>
                  </ul>
                  <p>
                    *Ensure <code>endpoint</code> matches what LM Studio shows.* The <code>model_name</code> must exactly match the model name in LM Studio. MMAT’s LM Studio provider will use this to send requests for inference.
                  </p>
                </li>
                <li>
                  <p><strong>Run MMAT:</strong></p>
                  <ul>
                    <li>With LM Studio running and serving the required models, you can now run MMAT commands (e.g., <code>mmat run</code>, <code>mmat build</code>) that use those local models.</li>
                  </ul>
                </li>
              </ol>
            </div>
          </div>

          <!-- 4. Understanding Graphs in MMAT -->
          <div id="section-understanding-graphs-in-mmat" class="content-section">
            <h2 id="understanding-graphs-in-mmat">4. Understanding Graphs in MMAT</h2>
            <p>
              The <code>graph/</code> module in MMAT is planned to handle internal representations and interactions related to test flows,
              dependencies, or other structural aspects of the testing process. This is likely an internal component used for analysis,
              visualization, or orchestration, rather than requiring a separate graph database or visualization tool for basic usage.
            </p>
            <p>
              Detailed setup for visualizing or interacting with these internal graph structures will be provided in future documentation. For
              standard test execution, you typically don’t need any extra graph setup beyond installing and configuring MMAT as described above.
            </p>
          </div>

          <!-- 5. Usage (Planned) -->
          <div id="section-usage-planned" class="content-section">
            <h2 id="usage-planned">5. Usage (Planned)</h2>
            <p>MMAT provides a command-line interface (CLI) to interact with the framework, primarily through the <code>run</code> and <code>build</code> commands.</p>

            <!-- 5.1 mmat run -->
            <div id="section-mmat-run" class="content-section">
              <h3>5.1. <a id="mmat-run"></a><code>mmat run</code></h3>
              <p>The <code>mmat run</code> command is used to execute a specified test plan. When you run a test plan, MMAT will:</p>
              <ol>
                <li>Load configuration from the specified <code>--config</code> file.</li>
                <li>Load the test plan (given by <code><plan_identifier></code> and <code>--plan-type</code>).</li>
                <li>Initialize environments and models as defined in the configuration.</li>
                <li>Iterate through test suites and test cases in the test plan.</li>
                <li>Execute each test step sequentially using the configured environment (e.g., a browser).</li>
                <li>Perform validations and assertions as defined.</li>
                <li>Collect results and generate reports using the configured reporters.</li>
              </ol>
              <p><strong>Syntax:</strong></p>
              <pre><code class="language-bash">mmat run <plan_identifier> --plan-type <type> --config <config_file> [options]</code></pre>
              <ul>
                <li><code><plan_identifier></code>: Path to your test plan file (e.g., <code>tests/functional/login_test_plan.yaml</code>).</li>
                <li><code>--plan-type <type></code>: Format of the test plan (e.g., <code>yaml</code>, <code>json</code>).</li>
                <li><code>--config <config_file></code>: Path to your MMAT configuration file (e.g., <code>config/config.yaml</code>).</li>
                <li><code>[options]</code>: Additional options (e.g., filtering test cases, verbosity).</li>
              </ul>
              <p><strong>Example:</strong></p>
              <pre><code class="language-bash">mmat run tests/functional/login_test_plan.yaml --plan-type yaml --config config/config.yaml</code></pre>
              <p>This will execute the test plan in <code>tests/functional/login_test_plan.yaml</code> with settings from <code>config/config.yaml</code>.</p>
            </div>

            <!-- 5.2 mmat build -->
            <div id="section-mmat-build" class="content-section">
              <h3>5.2. <a id="mmat-build"></a><code>mmat build</code></h3>
              <p>
                The <code>mmat build</code> command is intended for generating or processing test plans—often using the configured models. Its primary
                roles may include:
              </p>
              <ul>
                <li>Generating a structured test plan (YAML/JSON) from a less-structured input (e.g., a functional description) using a reasoning model.</li>
                <li>Updating or expanding an existing test plan based on new information or analysis.</li>
                <li>Performing static analysis on a test plan.</li>
              </ul>
              <p><strong>Syntax:</strong></p>
              <pre><code class="language-bash">mmat build <input_identifier> --input-type <type> --output <output_path> --config <config_file> [options]</code></pre>
              <ul>
                <li><code><input_identifier></code>: Source for building the plan (e.g., a functional description file, URL, etc.).</li>
                <li><code>--input-type <type></code>: Format of the input (e.g., <code>markdown</code>, <code>url</code>, <code>json</code>).</li>
                <li><code>--output <output_path></code>: Path to save the generated/processed test plan (e.g., <code>tests/generated/auth_tests.yaml</code>).</li>
                <li><code>--config <config_file></code>: Path to your MMAT configuration file (for models, environment, etc.).</li>
                <li><code>[options]</code>: Additional options controlling generation.</li>
              </ul>
              <p><strong>Example:</strong></p>
              <pre><code class="language-bash">mmat build functional_description.md --input-type markdown --output tests/generated/auth_tests.yaml --config config/config.yaml</code></pre>
              <p>
                This would generate a YAML test plan at <code>tests/generated/auth_tests.yaml</code> based on <code>functional_description.md</code>,
                using models defined in <code>config/config.yaml</code>.
              </p>
            </div>

            <!-- 5.3 mmat export -->
            <div id="section-mmat-export" class="content-section">
              <h3>5.3. <a id="mmat-export"></a><code>mmat export</code></h3>
              <p>
                The <code>mmat export</code> command converts an existing MMAT test plan into executable code (e.g., Playwright Python). This lets
                you run tests outside MMAT or use the generated script as a starting point.
              </p>
              <p>When you run <code>mmat export</code>, MMAT will:</p>
              <ol>
                <li>Load the specified test plan.</li>
                <li>Translate test steps into the syntax of the target format (e.g., Playwright Python API calls).</li>
                <li>Save the generated code to the specified output file.</li>
              </ol>
              <p><strong>Syntax:</strong></p>
              <pre><code class="language-bash">mmat export <test_plan_path> --output <output_path> [--force]</code></pre>
              <ul>
                <li><code><test_plan_path></code>: Path to the MMAT test plan (e.g., <code>tests/functional/login_test_plan.yaml</code>).</li>
                <li><code>--output <output_path></code>: Path where generated code should be saved (e.g., <code>exported_tests/login_test.py</code>).</li>
                <li><code>--force</code> (Optional): Overwrite the output file if it exists.</li>
              </ul>
              <p><strong>Example:</strong></p>
              <pre><code class="language-bash">mmat export tests/functional/login_test_plan.yaml --output exported_tests/login_test.py</code></pre>
              <p>
                This will export <code>tests/functional/login_test_plan.yaml</code> to a Playwright Python file named <code>login_test.py</code>
                in <code>exported_tests</code>.
              </p>
              <p><strong>Example of Generated Playwright Code (<code>exported_tests/login_test.py</code>):</strong></p>
              <pre><code class="language-python">import pytest
from playwright.sync_api import Page, sync_playwright

# Test Suite: Standard Login
# Description: Test standard user login scenarios

# Test Case: Successful Login with Valid Credentials
# Description: Verify a user can log in successfully
def test_successful_login(page: Page):
    page.goto("/login")
    page.fill('#username', 'testuser')
    page.fill('#password', 'password123')
    page.click('#login-button')
    # Verify redirection to dashboard
    assert page.url.endswith('/dashboard')

# Test Case: Failed Login with Invalid Password
# Description: Verify login fails with incorrect password
def test_failed_login_invalid_password(page: Page):
    page.goto("/login")
    page.fill('#username', 'testuser')
    page.fill('#password', 'wrongpassword')
    page.click('#login-button')
    # Verify error message is displayed
    assert page.is_visible('.error-message')</code></pre>
            </div>

            <!-- 5.4 mmat import-e2e -->
            <div id="section-mmat-import-e2e" class="content-section">
              <h3>5.4. <a id="mmat-import-e2e"></a><code>mmat import-e2e</code></h3>
              <p>
                The <code>mmat import-e2e</code> command converts an existing end-to-end test script (currently supports Playwright Python) into an MMAT functional test plan (YAML or JSON). This allows you to bring existing automated tests into the MMAT framework for management, analysis, or further processing.
              </p>
              <p>When you run <code>mmat import-e2e</code>, MMAT will:</p>
              <ol>
                <li>Parse the specified E2E test script.</li>
                <li>Identify test cases and steps within the script.</li>
                <li>Translate the identified actions and elements into MMAT test steps.</li>
                <li>Structure the results into an MMAT TestSuite and TestCases.</li>
                <li>Output the resulting test plan in YAML or JSON format.</li>
              </ol>
              <p><strong>Syntax:</strong></p>
              <pre><code class="language-bash">mmat import-e2e <input_file> [--output <output_path>] [--force]</code></pre>
              <ul>
                <li><code><input_file></code>: Path to the E2E test script file (e.g., <code>tests/e2e/login_test.py</code>).</li>
                <li><code>--output <output_path></code> (Optional): Path to save the generated MMAT test plan (e.g., <code>imported_plans/login_plan.yaml</code>). If not provided, the plan is printed to standard output.</li>
                <li><code>--force</code> (Optional): Overwrite the output file if it exists.</li>
              </ul>
              <p><strong>Example:</strong></p>
              <pre><code class="language-bash">mmat import-e2e tests/e2e/test_user_login.py --output tests/functional/imported_user_login_plan.yaml</code></pre>
              <p>
                This will import the Playwright script <code>tests/e2e/test_user_login.py</code> and save the resulting MMAT test plan to
                <code>tests/functional/imported_user_login_plan.yaml</code>.
              </p>
            </div>
          </div>

          <!-- 6. Contributing (Planned) -->
          <div id="section-contributing-planned" class="content-section">
            <h2 id="contributing-planned">6. Contributing (Planned)</h2>
            <p>
              Contributions are welcome! Please see the <code>CONTRIBUTING.md</code> (to be created) for details on how to propose changes, run tests,
              and submit pull requests.
            </p>
          </div>

          <!-- 7. License -->
          <div id="section-license" class="content-section">
            <h2 id="license">7. License</h2>
            <p>
              This project is licensed under the MIT License—see the <a href="LICENSE">LICENSE</a> file for details.
            </p>
          </div>

          <!-- 8. Acknowledgments -->
          <div id="section-acknowledgments" class="content-section">
            <h2 id="acknowledgments">8. Acknowledgments</h2>
            <ul>
              <li>Mention any libraries, tools, or resources that were helpful.</li>
            </ul>
          </div>

          <!-- 9. Features (Planned) -->
          <div id="section-features-planned" class="content-section">
            <h2 id="features-planned">9. Features (Planned)</h2>
            <ul>
              <li><strong>Model-based Test Plan Generation:</strong> Generate test suites and test cases from functional descriptions or structured data using AI models.</li>
              <li><strong>Environment Interaction:</strong> Interact with various environments (e.g., web browsers via Puppeteer) to execute test steps.</li>
              <li><strong>Test Data Management:</strong> Manage and utilize test data for test execution.</li>
              <li><strong>Validation and Analysis:</strong> Validate test results and analyze outcomes using models.</li>
              <li><strong>Reporting:</strong> Generate test reports in various formats.</li>
              <li><strong>Plugin System:</strong> Allow extending the framework with custom components (environments, reporters, models, etc.).</li>
              <li><strong>CLI Interface:</strong> Command-line interface for running and building test plans.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

   <!-- ----------------------------------------
       JavaScript to toggle content sections
       ---------------------------------------- -->

  <!-- ----------------------------------------------------
       JavaScript: Show only nested subsection when clicked
       ---------------------------------------------------- -->
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const sidebarLinks = document.querySelectorAll(".sidebar a");
      const containerInner = document.querySelector(".container-inner");
      // Only direct children of .container-inner with class "content-section"
      const topLevelSections = Array.from(
        containerInner.querySelectorAll(":scope > .content-section")
      );

      // Reset all inline display styles on children of the given top-level section
      const resetTopChildren = (section) => {
        Array.from(section.children).forEach(child => {
          child.style.display = "";
        });
      };

      // Hide all top-level sections, remove "active", and reset children
      const hideAllTopSections = () => {
        topLevelSections.forEach(section => {
          section.classList.remove("active");
          // Remove "active" from any nested .content-section
          section.querySelectorAll(".content-section.active").forEach(nested => {
            nested.classList.remove("active");
          });
          // Reset inline styles
          resetTopChildren(section);
        });
      };

      // Remove “active” class from every sidebar link
      const removeActiveClassFromLinks = () => {
        sidebarLinks.forEach(link => link.classList.remove("active"));
      };

      // On page load, show the “Overview” section by default
      hideAllTopSections();
      const overviewSection = document.getElementById("section-overview");
      if (overviewSection) {
        overviewSection.classList.add("active");
        const overviewLink = document.querySelector('.sidebar a[href="#section-overview"]');
        if (overviewLink) overviewLink.classList.add("active");
      }

      // When any sidebar link is clicked...
      sidebarLinks.forEach(link => {
        link.addEventListener("click", event => {
          event.preventDefault();
          const targetId = link.getAttribute("href").substring(1);
          const targetSection = document.getElementById(targetId);
          if (!targetSection) return;

          hideAllTopSections();
          removeActiveClassFromLinks();

          // Find the top-level section containing this target
          let topContainer = targetSection;
          while (
            topContainer.parentElement &&
            topContainer.parentElement !== containerInner
          ) {
            topContainer = topContainer.parentElement;
          }
          // Show that top‐level section
          topContainer.classList.add("active");

          // If we clicked a nested subsection, hide everything in the parent except that subsection
          if (targetSection !== topContainer) {
            // First, hide all direct children of topContainer
            Array.from(topContainer.children).forEach(child => {
              child.style.display = "none";
            });
            // Then, only display the nested section we clicked
            targetSection.style.display = "block";
            targetSection.classList.add("active");
          } else {
            // If it’s a top‐level click, ensure all children are visible again
            resetTopChildren(topContainer);
          }

          // Highlight the clicked link
          link.classList.add("active");
        });
      });
    });
  </script>

</body>
</html>
